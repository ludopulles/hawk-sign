#include <stdint.h>

#include "inner.h"
#include "keygen.c"
#include "sign.c"
#include "vrfy.c"

/*
 * The following average lengths, in bits, have been measured on thousands
 * of random keys (fg = max length of the absolute value of coefficients
 * of f and g at that depth; FG = idem for the unreduced F and G; for the
 * maximum depth, F and G are the output of binary GCD, multiplied by q;
 * for each value, the average and standard deviation are provided).
 *
 * Binary case:
 *    depth:  9    fg: 2369.72 (24.19)    FG:  2367.83 (24.18)
 *    depth:  8    fg: 1184.95 (12.09)    FG:  3535.44 (32.19)
 *    depth:  7    fg:  598.30 ( 7.09)    FG:  1772.94 (16.40)
 *    depth:  6    fg:  302.97 ( 4.17)    FG:  893.58 (9.30)
 *    depth:  5    fg:  153.62 ( 2.40)    FG:  451.73 (5.47)
 *    depth:  4    fg:   77.63 ( 1.31)    FG:  228.97 (3.18)
 *    depth:  3    fg:   38.68 ( 0.67)    FG:  116.22 (1.76)
 *    depth:  2    fg:   18.62 ( 0.49)    FG:  58.89 (0.95)
 *    depth:  1    fg:    8.05 ( 0.21)    FG:  29.77 (0.52)
 *    depth:  0    fg:    3.00 ( 0.04)    FG:  15.00 (0.14)
 *
 * Integers are actually represented either in binary notation over
 * 31-bit words (signed, using two's complement), or in RNS, modulo
 * many small primes. These small primes are close to, but slightly
 * lower than, 2^31. Use of RNS loses less than two bits, even for
 * the largest values.
 *
 * IMPORTANT: if these values are modified, then the temporary buffer
 * sizes (FALCON_KEYGEN_TEMP_*, in inner.h) must be recomputed
 * accordingly.
 *
 * Note, to get the values in LILIPU_MAX_BL_SMALL and LILIPU_MAX_BL_LARGE,
 * take ceil( (avg + 6 stddev) / 31 ) to arrive at the number of ints used to
 * represent a number at a certain depth.
*/

static const size_t LILIPU_MAX_BL_SMALL[10] = {
//  1, 1, 2, 2, 4, 7, 14, 27, 53, 106, 209 // (FALCON)
	1, 1, 2, 2, 4, 6, 11, 21, 41,  82 //, ??
};

static const size_t LILIPU_MAX_BL_LARGE[9] = {
//	2, 2, 5, 7, 12, 21, 40, 78, 157, 308 // (FALCON)
	2, 2, 3, 5, 8, 16, 31, 61, 121 //, ??
};

/*
 * Average and standard deviation for the maximum size (in bits) of
 * coefficients of (f,g), depending on depth. These values are used
 * to compute bounds for Babai's reduction.
 */
static const struct {
	int avg;
	int std;
} LILIPU_BITLENGTH[10] = {
	{ 4, 0 },
	{ 9, 1 },
	{ 19, 1 },
	{ 39, 1 },
	{ 78, 2 },
	{ 154, 3 },
	{ 303, 4 },
	{ 599, 7 },
	{ 1185, 12 },
	{ 2370, 24 }
	// , { ???, ??? }
};

// =============================================================================
// | Key generation                                                            |
// =============================================================================
/**
 * Compute a secret key and a public key belonging to the signature scheme.
 * The secret key is a tuple (f, g, F, G) where each belongs to the ring
 * Z[X] / (X^n + 1) with small coefficients (abs. value << 127), such that
 *
 *     f * G - g * F = 1 (mod X^n+1),
 *
 * holds. The public is given by the Gram matrix of the basis generated by the
 * basis vectors (f, g) and (F, G).
 * Here, isigma_kg is the inverse of the standard deviation used to generate
 * coefficients of f and g.
 *
 * tmp: buffer for intermediate values, of size >= 28*512 = 14336 bytes.
 */
void
lilipu_keygen(inner_shake256_context *rng,
	int8_t *restrict f, int8_t *restrict g, // secret key
	int8_t *restrict F, int8_t *restrict G, // secret key
	fpr *restrict q00, fpr *restrict q10, fpr *restrict q11, // public key
	unsigned logn, uint8_t *restrict tmp, fpr isigma_kg);

// =============================================================================
// | Signature generation                                                      |
// =============================================================================
/*
 * Compute a signature: the signature contains two vectors, s0 and s1.
 * The s0 vector is not returned. The squared norm of (s0,s1) is
 * computed, and if it is short enough, then s1 is returned into the
 * s1[] buffer, and 1 is returned; otherwise, s1[] is untouched and 0 is
 * returned; the caller should then try again.
 *
 * tmp: buffer for intermediate values, of size >= 42*512 = 21504 bytes.
 */
void
lilipu_sign(inner_shake256_context *rng, int16_t *restrict sig,
	const int8_t *restrict f, const int8_t *restrict g,
	const int8_t *restrict hm, unsigned logn, fpr isigma_sig,
	uint8_t *restrict tmp);

void
lilipu_complete_sign(inner_shake256_context *rng,
	int16_t *restrict s0, int16_t *restrict s1,
	const int8_t *restrict f, const int8_t *restrict g,
	const int8_t *restrict F, const int8_t *restrict G,
	const int8_t *restrict hm, unsigned logn, fpr isigma_sig,
	uint8_t *restrict tmp);

// =============================================================================
// | Signature validation                                                      |
// =============================================================================
/**
 * Verify if a signature is a valid signature (i.e. generated by someone having
 * access to the secret key).
 *
 * hm: hashed message of length n = 2^logn with values in {0,1}
 * s0: buffer of length n, that will be filled with a value that minimizes the
 *     value (s0 s1) Q (s0 s1)^T.
 * s1: buffer of length n, containing the signature
 * q00, q10, q11: represents the matrix Q = [[q00, q10^T], [q10, q11]].
 * verif_bound: if a signature (s0, s1) has Tr((s0 s1) Q (s0 s1)^T) smaller than
 *              this bound, the signature is accepted.
 *
 * Note: q00, q11 are self adjoint.
 * tmp: buffer for intermediate values, of size >= 32*512 = 16384 bytes.
 */
int
lilipu_verify(const int8_t *restrict hm,
	int16_t *restrict s0, const int16_t *restrict s1,
	const fpr *restrict q00, const fpr *restrict q10, const fpr *restrict q11,
	unsigned logn, const fpr verif_bound, uint8_t *restrict tmp);
